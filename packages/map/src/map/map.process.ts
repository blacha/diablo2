import { ChildProcess, spawn, spawnSync } from 'child_process';
import { EventEmitter } from 'events';
import PLimit from 'p-limit';
import { createInterface } from 'readline';
import { Log, LogType } from '../logger';
import { Diablo2Map, Diablo2MapGenMessage, MapGenMessageInfo, MapGenMessageMap } from './map';

export const MapCommand = './bin/d2-map.exe';
export const Diablo2Path = './game/Path of Diablo';
export const WineCommand = 'wine';

/** Wait at most 10 seconds for things to work */
const ProcessTimeout = 10000;
const MaxMapsToGenerate = 1;

async function timeOut(message: string, timeout: number): Promise<void> {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => reject(`${message} Timeout after ${timeout}ms`), timeout);
    timer.unref();
  });
}

function getJson<T>(s: string): T | null {
  try {
    return JSON.parse(s);
  } catch (e) {
    return null;
  }
}

const cwd = process.cwd();
export class Diablo2MapProcess {
  process: ChildProcess | null;
  /** Number of maps generated by this process */
  generatedCount = 0;
  events: EventEmitter = new EventEmitter();
  /**
   * Limit the map generation to a single thread
   * TODO having a pool of these map processes would be quite nice
   */
  q = PLimit(1);

  /** Get the version of WINE that is being used */
  async version(log: LogType): Promise<string> {
    const versionResponse = spawnSync(WineCommand, ['--version']);
    const version = versionResponse.stdout.toString();
    log.info({ version, command: WineCommand }, 'WineVersion');
    return version;
  }

  /** Start the map process waiting for the `init` event before allowing anything to continue */
  async start(log: LogType): Promise<void> {
    if (this.process != null) {
      Log.warn({ pid: this.process.pid }, 'MapProcess already started');
      return;
    }
    this.generatedCount = 0;
    const args = [MapCommand, Diablo2Path];
    log.info({ wineArgs: args }, 'Starting MapProcess');

    return new Promise(async (resolve) => {
      const process = spawn(WineCommand, args, { cwd });
      if (process == null || process.stdout == null) throw new Error('Failed to start command');
      this.process = process;
      process.stderr.on('data', (data) => {
        Log.debug({ data: data.toString().trim() }, 'MapProcess:stderr');
      });
      process.on('error', (error) => {
        log.fatal({ error }, 'ProcessDied');
        inter.close();
        this.process = null;
      });
      process.on('close', (exitCode) => {
        inter.close();
        this.process = null;
        if (exitCode > 0) log.fatal({ exitCode }, 'ProcessClosed');
      });

      log.info({ pid: process.pid }, 'MapProcessStarted');
      const inter = createInterface(process.stdout).on('line', (line) => {
        const json = getJson<Diablo2MapGenMessage>(line);
        if (json == null) return;
        if (json.type) this.events.emit(json.type, json);
      });
      await this.once('init');
      resolve();
    });
  }

  async once<T extends Diablo2MapGenMessage>(e: T['type'], cb?: () => void): Promise<T> {
    return Promise.race([
      new Promise((resolve) => {
        this.events.once(e, (data) => resolve(data));
        cb?.();
      }),
      timeOut(`Event: ${e}`, ProcessTimeout),
    ]) as Promise<T>;
  }

  async stop(log: LogType): Promise<void> {
    if (this.process == null) return;
    log.info({ pid: this.process.pid }, 'StoppingProcess');
    this.process.kill('SIGKILL');
    this.process = null;
  }

  async command(cmd: 'seed' | 'difficulty', value: number, log: LogType): Promise<void> {
    if (this.process == null) await this.start(log);
    const command = `$${cmd} ${value}\n`;

    console.log('SendCommand', command);
    const res = await this.once<MapGenMessageInfo>('info', () => this.process?.stdin?.write(command));
    if (res[cmd] != value)
      throw new Error(`Failed to set ${cmd}=${value} (output: ${JSON.stringify(res)}: ${command})`);
  }

  map(seed: number, difficulty: number, log: LogType): Promise<{ [key: string]: Diablo2Map }> {
    return this.q(() => this.getMaps(seed, difficulty, log));
  }

  private async getMaps(seed: number, difficulty: number, log: LogType): Promise<{ [key: string]: Diablo2Map }> {
    if (this.generatedCount > MaxMapsToGenerate) {
      this.generatedCount = 0;
      await this.stop(log);
      await this.start(log);
    }

    await this.command('seed', seed, log);
    await this.command('difficulty', difficulty, log);

    this.generatedCount++;
    log.info({ seed, difficulty, generated: this.generatedCount }, 'GenerateMap');
    const maps: Record<string, Diablo2Map> = {};

    const newMap = (msg: MapGenMessageMap): void => {
      log.trace({ mapId: msg.id }, 'GotMap');
      maps[msg.id] = msg;
    };

    return await new Promise((resolve, reject) => {
      const failedTimer = setTimeout(() => {
        this.events.off('map', newMap);
        reject();
      }, ProcessTimeout);
      this.events.on('map', newMap);
      this.events.on('done', () => {
        clearTimeout(failedTimer);
        log.trace({ count: Object.keys(maps).length }, 'MapsGenerated');
        resolve(maps);
      });
      this.process?.stdin?.write(`$map\n`);
    });
  }
}

export const MapProcess = new Diablo2MapProcess();
