import { Diablo2Level, Diablo2LevelNpcSuper, Diablo2MpqData } from '@diablo2/data';
import { Diablo2MpqLoader } from '@diablo2/bintools';
import { toHex } from 'binparse';
import { ChildProcess, spawn } from 'child_process';
import { promises as fs } from 'fs';
import { EventEmitter } from 'events';
import PLimit from 'p-limit';
import { createInterface } from 'readline';
import { Log, LogType } from '../logger.js';
import { run } from './child.process.js';
import { LruCache } from './lru.js';
import { Diablo2MapGenMessage, MapGenMessageInfo, MapGenMessageMap } from './map.js';
import { F_OK } from 'constants';

export const MapCommand = ['./bin/d2-map.exe', '../bin/d2-map.exe'];
export const Diablo2Path = '/app/game';
export const RegistryPath = '/app/d2.install.reg';
export const WineCommand = 'wine';

/** Wait at most 10 seconds for things to work */
const ProcessTimeout = 30_000;
const MaxMapsToGenerate = 50;

interface LogMessage {
  time: number;
  level: number;
  msg: string;
}

async function timeOut(message: string, timeout: number): Promise<void> {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => reject(`${message} Timeout after ${timeout}ms`), timeout);
    timer.unref();
  });
}

function getJson<T>(s: string): T | null {
  try {
    return JSON.parse(s);
  } catch (e) {
    return null;
  }
}

function fileExists(f: string): Promise<boolean> {
  return fs
    .access(f, F_OK)
    .then(() => true)
    .catch(() => false);
}

// Disable wine debug logging
const cwd = process.cwd();
export class Diablo2MapProcess {
  cache: LruCache<Diablo2Level[]> = new LruCache(100);
  process: ChildProcess | null;
  /** Number of maps generated by this process */
  generatedCount = 0;
  events: EventEmitter = new EventEmitter();
  mpq: Diablo2MpqData;

  isFirstStart = true;
  /**
   * Limit the map generation to a single thread
   * TODO having a pool of these map processes would be quite nice
   */
  q = PLimit(1);

  /** Get the version of WINE that is being used */
  async version(log: LogType): Promise<string> {
    const versionResponse = await run(WineCommand, ['--version']);
    const version = versionResponse.stdout;
    log.info({ version, command: WineCommand }, 'MapProcess:WineVersion');
    return version;
  }

  async findD2MapExe(): Promise<string | null> {
    for (const mc of MapCommand) {
      if (await fileExists(mc)) return mc;
    }

    return null;
  }

  /** Start the map process waiting for the `init` event before allowing anything to continue */
  async start(log: LogType): Promise<void> {
    if (this.process != null) {
      Log.warn({ pid: this.process.pid }, 'MapProcess:AlreadyStarted');
      return;
    }
    this.generatedCount = 0;

    if (this.mpq == null) this.mpq = await Diablo2MpqLoader.load(Diablo2Path, log);

    const mapCommand = await this.findD2MapExe();
    if (mapCommand == null) {
      Log.fatal('MapProcess:MissingMapExe');
      return;
    }

    log.info({ exe: mapCommand }, 'MapProcess:ExeFound');

    if ((await fileExists(RegistryPath)) && this.isFirstStart) {
      const res = await run(WineCommand, ['regedit', RegistryPath]);
      log.info({ data: res.stdout }, 'MapProcess:Registry:Update');
    }

    const args = [mapCommand, Diablo2Path];
    log.info({ wineArgs: args }, 'MapProcess:Starting');
    this.isFirstStart = false;

    return new Promise(async (resolve) => {
      const proc = spawn(WineCommand, args, { cwd, env: { WINEPREFIX: process.env['WINEPREFIX'], WINEDEBUG: '-all' } });
      if (proc == null || proc.stdout == null) throw new Error('Failed to start command');
      this.process = proc;
      proc.stderr.on('data', (data) => {
        const line = data.toString().trim();
        if (line.includes('FS volume label and serial are not available')) return;
        Log.debug({ data: line }, 'MapProcess:stderr');
      });
      proc.on('error', (error) => {
        log.fatal({ error }, 'MapProcess:Died');
        inter.close();
        this.process = null;
      });
      proc.on('close', (exitCode) => {
        inter.close();
        this.process = null;
        if (exitCode == null) return;
        if (exitCode > 0) log.fatal({ exitCode }, 'MapProcess:Closed');
      });

      log.info({ pid: proc.pid }, 'MapProcess:Started');
      const inter = createInterface(proc.stdout).on('line', (line) => {
        const json = getJson<Diablo2MapGenMessage | LogMessage>(line);
        if (json == null) return;
        if ('time' in json) {
          if (json.level < 30) return;
          Log.info({ ...json, log: json.msg }, 'MapProcess:Log');
        } else if (json.type) this.events.emit(json.type, json);
      });
      await this.once('init');
      resolve();
    });
  }

  async once<T extends Diablo2MapGenMessage>(e: T['type'], cb?: () => void): Promise<T> {
    return Promise.race([
      new Promise((resolve) => {
        this.events.once(e, (data) => resolve(data));
        cb?.();
      }),
      timeOut(`Event: ${e}`, ProcessTimeout),
    ]) as Promise<T>;
  }

  async stop(log: LogType): Promise<void> {
    if (this.process == null) return;
    log.info({ pid: this.process.pid }, 'MapProcess:Stop');
    this.process.kill('SIGKILL');
    this.process = null;
  }

  async command(cmd: 'seed' | 'difficulty' | 'act', value: number, log: LogType): Promise<void> {
    const startTime = Date.now();
    if (this.process == null) await this.start(log);
    const command = `$${cmd} ${value}\n`;
    const res = await this.once<MapGenMessageInfo>('info', () => this.process?.stdin?.write(command));
    if (res[cmd] !== value) {
      throw new Error(`Failed to set ${cmd}=${value} (output: ${JSON.stringify(res)}: ${command})`);
    }

    log.trace({ cmd, value, duration: Date.now() - startTime }, 'MapProcess:Command');
  }

  map(seed: number, difficulty: number, actId: number, log: LogType): Promise<Diablo2Level[]> {
    const mapKey = `${seed}_${difficulty}_${actId}`;
    const cacheData = this.cache.get(mapKey);
    if (cacheData != null) return Promise.resolve(cacheData);
    return this.q(async () => {
      const mapResult = await this.getMaps(seed, difficulty, actId, log);
      this.cache.set(mapKey, mapResult);
      return mapResult;
    });
  }

  private async getMaps(seed: number, difficulty: number, actId: number, log: LogType): Promise<Diablo2Level[]> {
    if (this.generatedCount > MaxMapsToGenerate) {
      this.generatedCount = 0;
      await this.stop(log);
      await this.start(log);
    }

    await this.command('seed', seed, log);
    await this.command('difficulty', difficulty, log);
    if (actId > -1) await this.command('act', actId, log);

    this.generatedCount++;
    log.info({ seed: toHex(seed, 8), difficulty, generated: this.generatedCount }, 'GenerateMap:Start');
    const maps: Map<number, Diablo2Level> = new Map();

    const newMap = (msg: MapGenMessageMap): void => {
      log?.trace({ mapId: msg.id }, 'GenerateMap:GotMap');
      maps.set(msg.id, this.fixMap(msg));
    };

    return await new Promise((resolve, reject) => {
      const failedTimer = setTimeout(() => {
        this.events.off('map', newMap);
        reject();
      }, ProcessTimeout);
      this.events.on('map', newMap);
      this.events.on('done', () => {
        this.events.off('map', newMap);
        clearTimeout(failedTimer);
        log?.trace({ count: Object.keys(maps).length }, 'GenerateMap:Generated');
        resolve([...maps.values()]);
      });
      this.process?.stdin?.write(`$map\n`);
    });
  }

  /** Correct the names of npcs and objects */
  fixMap(map: MapGenMessageMap): MapGenMessageMap {
    map.name = this.mpq.levels.get(map.id)?.name.trim() ?? map.name;
    for (const obj of map.objects) {
      if (obj.type === 'npc') {
        if (obj.id >= this.mpq.monsters.size) {
          const superId = obj.id - this.mpq.monsters.size;

          if (superId < this.mpq.monsters.superUniques.length) {
            obj.name = this.mpq.monsters.superUniqueName(superId);
            (obj as Diablo2LevelNpcSuper).isSuperUnique = true;
            (obj as Diablo2LevelNpcSuper).superId = superId;
          }
        } else {
          obj.name = this.mpq.monsters.name(obj.id)?.trim();
        }
      }

      // Force lowercase all the sub types
      if (obj.type === 'object') {
        obj.name = this.mpq.objects.get(obj.id)?.name.trim();
      }

      if (obj.type === 'exit') {
        obj.name = this.mpq.levels.get(obj.id)?.name.trim();
      }
    }

    return map;
  }
}

export const MapProcess = new Diablo2MapProcess();
